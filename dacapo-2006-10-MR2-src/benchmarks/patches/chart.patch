diff -N -u -r chart/dacapo/Datasets.java chart/dacapo/Datasets.java
--- chart/dacapo/Datasets.java	1970-01-01 10:00:00.000000000 +1000
+++ chart/dacapo/Datasets.java	2005-09-27 11:43:51.000000000 +1000
@@ -0,0 +1,903 @@
+package dacapo;
+
+import org.jfree.data.*;
+import org.jfree.data.category.*;
+import org.jfree.data.general.*;
+import org.jfree.data.xy.*;
+import java.io.*;
+import java.util.*;
+import java.net.URL;
+
+public abstract class Datasets implements GraphConstants {
+  
+  private static int positiveSeriesCount = 0;
+  private static int negativeSeriesCount = 0;
+
+  /**
+   * Get a histogram dataset
+   */
+  public static CategoryDataset getHistDataset(URL fromFile, int chartType,
+					       int withTimeline) 
+    throws Exception {
+    return getHistDataset(fromFile, chartType, withTimeline, RANGE_IN_MB);
+  }
+  
+  /**
+   * Get a histogram dataset
+   */
+  public static CategoryDataset getHistDataset(URL fromFile, int chartType, 
+					       int withTimeline, int rangeIn) 
+    throws Exception {
+
+    double[][] result = null;
+
+    switch (chartType) {
+      // Histograms
+    case PERFECT_PTR_DIST_HIST:
+      result = createPointerDistHistData(fromFile, true, false, withTimeline);
+      return createCategoryDataset("", "", result);
+    case PERFECT_PTR_SRC_HIST:
+      result = createPtrAgeHistData(fromFile, true, true, false, withTimeline);
+      return createCategoryDataset("", "", result);
+    case PERFECT_PTR_TGT_HIST:
+      result = createPtrAgeHistData(fromFile, false, true, false, withTimeline);
+      return createCategoryDataset("", "", result);
+    case PERFECT_MUT_DIST_HIST:
+      result = createPointerDistHistData(fromFile, true, true, withTimeline);
+      return createCategoryDataset("", "", result);
+    case PERFECT_MUT_SRC_HIST:
+      result = createPtrAgeHistData(fromFile, true, true, true, withTimeline);
+      return createCategoryDataset("", "", result);
+    case PERFECT_MUT_TGT_HIST:
+      result = createPtrAgeHistData(fromFile, false, true, true, withTimeline);
+      return createCategoryDataset("", "", result);
+    case PERFECT_HEAP_COMP_HIST:
+      result = createHeapHistData(fromFile, rangeIn);
+      return createCategoryDataset("", "", result);
+    case PERFECT_INV_HEAP_COMP_HIST:
+      result = createHeapHistData(fromFile, rangeIn);
+      return createCategoryDataset("", "", result);
+    case CUMULATIVE_PTR_DIST_HIST:
+      result = createPointerDistHistData(fromFile, false, false, withTimeline);
+      return createCategoryDataset("", "", result);
+    case CUMULATIVE_PTR_SRC_HIST:
+      result = createPtrAgeHistData(fromFile, true, false, false, withTimeline);
+      return createCategoryDataset("", "", result);
+    case CUMULATIVE_PTR_TGT_HIST:
+      result = createPtrAgeHistData(fromFile, false, false, false, withTimeline);
+    case CUMULATIVE_MUT_DIST_HIST:
+      result = createPointerDistHistData(fromFile, false, true, withTimeline);
+      return createCategoryDataset("", "", result);
+    case CUMULATIVE_MUT_SRC_HIST:
+      result = createPtrAgeHistData(fromFile, true, false, true, withTimeline);
+      return createCategoryDataset("", "", result);
+    case CUMULATIVE_MUT_TGT_HIST:
+      result = createPtrAgeHistData(fromFile, false, false, true, withTimeline);
+      return createCategoryDataset("", "", result);
+    default: System.out.println("getHistDataset: No such graph type"); 
+      break;
+    }
+    return null;
+  }
+  
+  /**
+   * Get a line-graph dataset
+   */
+  public static XYSeriesCollection getLineDataset(URL fromFile, 
+						  int forChartType, 
+						  int withTimeline)
+    throws Exception{
+    return getLineDataset(fromFile, forChartType, withTimeline, RANGE_IN_MB);
+  }
+  
+  /**
+   * Get a line-graph dataset
+   */
+  public static XYSeriesCollection getLineDataset(URL fromFile, 
+						  int forChartType, 
+						  int withTimeline, 
+						  int rangeIn) 
+    throws Exception {
+    
+    switch (forChartType) {
+      // XY-Line graphs
+    case PERFECT_PTR_DIST_XYPLOT:
+      return createPointerDistData(fromFile, true, false, withTimeline);
+    case PERFECT_PTR_SRC_XYPLOT:
+      return createPointerAgeData(fromFile, true, true, false, withTimeline);
+    case PERFECT_PTR_TGT_XYPLOT:
+      return createPointerAgeData(fromFile, false, true, false, withTimeline);
+    case PERFECT_MUT_DIST_XYPLOT:
+      return createPointerDistData(fromFile, true, true, withTimeline);
+    case PERFECT_MUT_SRC_XYPLOT:
+      return createPointerAgeData(fromFile, true, true, true, withTimeline);
+    case PERFECT_MUT_TGT_XYPLOT:
+      return createPointerAgeData(fromFile, false, true, true, withTimeline);
+    case PERFECT_HEAP_COMP_XYPLOT:
+      return createHeapData(fromFile, false, withTimeline, rangeIn);
+    case PERFECT_INV_HEAP_COMP_XYPLOT:
+      return createHeapData(fromFile, true, withTimeline, rangeIn);
+    case CUMULATIVE_PTR_DIST_XYPLOT:
+      return createPointerDistData(fromFile, false, false, withTimeline);
+    case CUMULATIVE_PTR_SRC_XYPLOT:
+      return createPointerAgeData(fromFile, true, false, false, withTimeline);
+    case CUMULATIVE_PTR_TGT_XYPLOT:
+      return createPointerAgeData(fromFile, false, false, false, withTimeline);
+    case CUMULATIVE_MUT_DIST_XYPLOT:
+      return createPointerDistData(fromFile, false, true, withTimeline);
+    case CUMULATIVE_MUT_SRC_XYPLOT:
+      return createPointerAgeData(fromFile, true, false, true, withTimeline);
+    case CUMULATIVE_MUT_TGT_XYPLOT:
+      return createPointerAgeData(fromFile, false, false, true, withTimeline);
+    default: System.out.println("getLineDateset: No such graph type"); 
+      break;
+    }
+    return null;
+  }
+
+  
+  private static CategoryDataset createCategoryDataset(String rowKeyPrefix,
+						       String columnKeyPrefix,
+						       double[][] data) {
+
+    DefaultCategoryDataset result = new DefaultCategoryDataset();
+    for (int r = 0; r < data.length; r++) {
+      String rowKey = rowKeyPrefix + r;
+      for (int c = 0; c < data[r].length; c++) {
+	String columnKey = columnKeyPrefix + c;
+	result.addValue(new Double(data[r][c]), rowKey, columnKey);
+      }
+    }
+    return result;
+  }
+
+  
+  public static double[][] createHeapHistData(URL inURL, int rangeIn)
+    throws IOException {
+
+    BufferedReader file = new BufferedReader(new InputStreamReader(inURL.openStream()));
+    
+    int index = 0;
+    int currCohortCount = 0;
+    String line = null;
+    String startTag, endTag;
+    StringTokenizer st = null;
+    
+    int maxCohort = getMaxCohorts(inURL); // index starts at 1
+    double[] cohortHist = new double[maxCohort];
+    
+    int denom = 1;
+    
+    switch (rangeIn) {
+    case RANGE_IN_KB:
+      denom = 1024; break;
+    case RANGE_IN_MB:
+      denom = 1024*1024; break;
+    default: break;
+    }
+    
+    double[] cohortVolumes;
+    
+    startTag = "<cohort data>";
+    endTag = "</cohort data>";
+    
+    while((line=file.readLine()) != null) {
+      if (line.equals("<cohort data>")) {
+	line = file.readLine(); // goto the next line
+	line = file.readLine(); // goto the next line
+	st = new StringTokenizer(line, ",");
+	st.nextToken();
+	st.nextToken(","); // ignore
+	currCohortCount = Integer.parseInt(st.nextToken(",")); // cohorts
+	
+	cohortVolumes = new double[currCohortCount];
+	line = file.readLine(); // goto the next line
+	do {
+	  st = new StringTokenizer(line, ",");
+	  index = Integer.parseInt(st.nextToken());
+	  st.nextToken(","); // ignore
+	  cohortVolumes[index] = Double.parseDouble(st.nextToken(","));
+	  line = file.readLine();
+	} while(!line.equals(endTag));
+	
+	for(int i=0;i < currCohortCount; i++) {
+	  cohortHist[i] = (cohortVolumes[i]==0)?0:cohortVolumes[i]/denom;
+	}
+      }
+    }
+    return new  double[][]{cohortHist};
+  }
+  
+  
+  private static double[][] createPointerDistHistData(URL inURL,
+						      boolean isPerfect,
+						      boolean isMutation,
+						      int timeline)
+    throws IOException {
+
+    BufferedReader file = new BufferedReader(new InputStreamReader(inURL.openStream()));
+
+    String temp = null;
+    String line = null;
+    StringTokenizer st;
+    
+    int posBuckets = 32; // 31 + extra
+    int negBuckets = 32; // 31 + extra
+    
+    double[] positive = null; int totalPositive = 0; double sum = 0;
+    double[] negative = null; int totalNegative = 0;
+    int maxPosFound = 0, maxNegFound = 0;
+    double totalZero = 0;
+
+    double[] totalPos = new double[posBuckets];
+    double[] totalNeg = new double[negBuckets];
+    
+    double totalMutations = 0;
+    double totalAllocs = 0;
+    double currentMutations = 0;
+    boolean isTimeAllocs = false;
+    
+    positive = new double[posBuckets]; //  0   -> 2^30
+    negative = new double[negBuckets]; // -2^1 -> -2^30
+    double zeroDistance = 0.0;
+    
+    String mutOrPoint = ((isMutation) ? "mutation " : "pointer ");
+    String primaryStartTag = "<"+mutOrPoint+"data>";
+    String primaryEndTag = "</"+mutOrPoint+"data>";
+    String baseTag = ((isPerfect) ? "perfect " : "") + mutOrPoint + "dist";
+    String startTag = "<"+baseTag+">";
+    String endTag = "</"+baseTag+">";
+    
+    switch (timeline) {
+    case TIMELINE_MUTATIONS:
+      isTimeAllocs = false; break;
+    case TIMELINE_ALLOCATIONS:
+      isTimeAllocs = true; break;
+    default: break;
+    }
+    
+    // How many buckets to read
+    final int READ_POS_BUCKETS = posBuckets;
+    final int READ_NEG_BUCKETS = negBuckets;
+    int dataPoint = 0;
+    
+    // Donot change these. Instead, change READ_POS/NEG_BUCKETS
+    int read_pos_buckets = READ_POS_BUCKETS;
+    int read_neg_buckets = READ_NEG_BUCKETS;
+    
+    while((line=file.readLine()) != null) {
+      if (line.equals(primaryStartTag)) {
+	line = file.readLine(); // goto the next line
+	st = new StringTokenizer(line, ",");
+        totalMutations = Double.parseDouble(st.nextToken());
+	totalAllocs = Double.parseDouble(st.nextToken(",")); // time
+        temp=file.readLine();
+	while (!temp.equals(startTag)) {
+	  temp=file.readLine();
+	}
+	
+	// Read Source Distances
+	temp = file.readLine(); // go to next line
+	do {
+	  st = new StringTokenizer(temp, ",");
+	  int index = Integer.parseInt(st.nextToken());
+          double value = Double.parseDouble(st.nextToken(","));
+          if (index == 0) 
+            zeroDistance = value;
+          else if (index < 0)
+            negative[-index-1] = value;
+          else 
+            positive[index-1] = value;
+
+	  temp=file.readLine();
+	} while(!temp.equals(endTag));
+
+        sum = zeroDistance;
+        totalZero += zeroDistance;
+	for(int i=0; i<read_pos_buckets; i++) {
+	  sum += positive[i];
+	  totalPos[i] += positive[i];
+	}
+	for(int i=0; i<read_neg_buckets; i++) {
+	  sum += negative[i];
+	  totalNeg[i] += negative[i];
+	}
+
+	// reset arrays
+	for(int i=0; i<read_pos_buckets; i++) {
+	  positive[i] = 0;
+	}
+	for(int i=0; i<read_neg_buckets; i++) {
+	  negative[i] = 0;
+	}
+	
+	totalPositive = 0;
+	totalNegative = 0;
+	sum = 0;
+	
+	// reset in case values changed
+	read_pos_buckets = READ_POS_BUCKETS;
+	read_neg_buckets = READ_NEG_BUCKETS;
+      }
+    }
+    
+    double[] posVals = new double[totalPos.length+1];
+    posVals[0] = ((totalZero/totalMutations)*100)/2;
+    for(int i=1;i<posVals.length;i++) {
+      posVals[i] = (totalPos[i-1]/totalMutations)*100;
+    }
+    
+    double[] negVals = new double[totalNeg.length+1];
+    negVals[0] = -((totalZero/totalMutations)*100)/2;
+    for(int i=1;i<negVals.length;i++) {
+      negVals[i] = -(totalNeg[i-1]/totalMutations)*100;
+    }
+    return new double[][]{posVals, negVals};
+  }
+  
+  public static XYSeriesCollection createHeapData(URL inURL,
+						  boolean invert,
+						  int timeLine,
+						  int rangeIn)
+    throws IOException {
+
+    BufferedReader file = new BufferedReader(new InputStreamReader(inURL.openStream()));
+    
+    int index = 0;
+    int currCohortCount = 0;
+    double totalAllocs = 0.0;
+    String line = null;
+    String startTag, endTag;
+    StringTokenizer st = null;
+    
+    int maxCohort = getMaxCohorts(inURL); // index starts at 1
+    double[] cohortHist = new double[maxCohort];
+    
+    double totalMutations = 0;
+    boolean isTimeAllocs = false;
+    int denom = 1;
+    
+    XYSeriesCollection dataset = new XYSeriesCollection();
+    XYSeries[] cohorts = new XYSeries[maxCohort];
+    double[] cohortVolumes;
+    
+    startTag = "<cohort data>";
+    endTag = "</cohort data>";
+    
+    switch (timeLine) {
+    case TIMELINE_MUTATIONS:
+      isTimeAllocs = false; break;
+    case TIMELINE_ALLOCATIONS:
+      isTimeAllocs = true; break;
+    default: break;
+    }
+    
+    switch (rangeIn) {
+    case RANGE_IN_KB:
+      denom = 1024; 
+      break;
+    case RANGE_IN_MB:
+      denom = 1024*1024; 
+      break;
+    default: break;
+    }
+    
+    while((line=file.readLine()) != null) {
+      if (line.equals("<cohort data>")) {
+	line = file.readLine(); // goto the next line
+	st = new StringTokenizer(line, ",");
+        totalMutations = Double.parseDouble(st.nextToken());
+	totalAllocs = Double.parseDouble(st.nextToken(",")); // time
+	line = file.readLine(); // goto the next line
+	st = new StringTokenizer(line, ",");
+	st.nextToken();
+	st.nextToken(","); // ignore
+	currCohortCount = Integer.parseInt(st.nextToken(",")); // cohorts
+	
+	cohortVolumes = new double[currCohortCount];
+	line = file.readLine(); // goto the next line
+	do {
+	  st = new StringTokenizer(line, ",");
+	  index = Integer.parseInt(st.nextToken());
+	  st.nextToken(","); // ignore obj count
+	  cohortVolumes[index] = Double.parseDouble(st.nextToken(","));
+	  line = file.readLine();
+	} while(!line.equals(endTag));
+	
+	// Calculate cumulative cohort volumes
+	double[] tempVolumes = new double[currCohortCount];
+	for(int i=0; i<currCohortCount; i++) {
+	  for(int j=currCohortCount-1; j>=i; j--) {
+	    tempVolumes[i] += cohortVolumes[j];
+	  }
+	}
+	
+	// add values to XYSeries
+	int cp = 0;
+	for(int i=0;i < currCohortCount; i++) {
+	  if (cohorts[i] == null) {
+	    cohorts[i]= new XYSeries("Cohort " + (i+1));
+	  }
+	  cp += cohortVolumes[i];
+	  if (!isTimeAllocs) {
+	    if (invert) {
+	      cohorts[i].add(totalMutations/1000000, cp/denom);
+	    } else {
+	      cohorts[i].add(totalMutations/1000000,tempVolumes[i]/denom);
+	    }
+	  } else {
+	    if (invert) {
+	      cohorts[i].add(totalAllocs, cp/denom);
+	    } else {
+	      cohorts[i].add(totalAllocs, tempVolumes[i]/denom);
+	    }
+	  }
+	  if (!invert) {
+	    cohortHist[i] = (cohortVolumes[i]==0)?0:cohortVolumes[i]/denom;
+	  }
+	}
+      }
+    }
+    
+    // add XYSeries to the collection
+    int i = 0;
+    while (i < maxCohort && cohorts[i] != null) {
+      dataset.addSeries(cohorts[i]);
+      i++;
+    }
+
+    return dataset;
+  }
+  
+  
+  private static XYSeriesCollection createPointerDistData(URL inURL,
+							  boolean isPerfect,
+							  boolean isMutation,
+							  int timeline) 
+    throws IOException {
+
+    BufferedReader file = new BufferedReader(new InputStreamReader(inURL.openStream()));
+
+    String temp = null;
+    String line = null;
+    StringTokenizer st;
+    
+    int posBuckets = 32; // 31 + extra
+    int negBuckets = 32; // 31 + extra
+    
+    double[] positive = null; 
+    double sum = 0;
+    double[] negative = null; 
+
+    int totalPositive = 0; 
+    int totalNegative = 0;
+    int maxPosFound = 0;
+    int maxNegFound = 0;
+    
+    XYSeriesCollection dataset = new XYSeriesCollection();      
+    XYSeries[] posdistances = new XYSeries[posBuckets];
+    XYSeries[] negdistances = new XYSeries[negBuckets];
+    
+    double totalMutations = 0;
+    double totalAllocs = 0;
+    double currentMutations = 0;
+    boolean isTimeAllocs = false;
+    
+    positive = new double[posBuckets]; //  0   -> 2^30
+    negative = new double[negBuckets]; // -2^1 -> -2^30
+    double zeroDistance = 0.0;
+
+    String mutOrPoint = ((isMutation) ? "mutation " : "pointer ");
+    String primaryStartTag = "<"+mutOrPoint+"data>";
+    String primaryEndTag = "</"+mutOrPoint+"data>";
+    String baseTag = ((isPerfect) ? "perfect " : "") + mutOrPoint + "dist";
+    String startTag = "<"+baseTag+">";
+    String endTag = "</"+baseTag+">";
+
+    switch (timeline) {
+    case TIMELINE_MUTATIONS:
+      isTimeAllocs = false; break;
+    case TIMELINE_ALLOCATIONS:
+      isTimeAllocs = true; break;
+    default: break;
+    }
+    
+    // How many buckets to read
+    final int READ_POS_BUCKETS = posBuckets;
+    final int READ_NEG_BUCKETS = negBuckets;
+    int dataPoint = 0;
+    
+    
+    // Donot change these. Instead, change READ_POS/NEG_BUCKETS
+    int read_pos_buckets = READ_POS_BUCKETS;
+    int read_neg_buckets = READ_NEG_BUCKETS;
+    
+    for(int i=0; i<posBuckets; i++) {
+      posdistances[i] = null;
+    }
+    for(int i=0; i<negBuckets; i++) {
+      negdistances[i] = null;
+    }
+    
+    while((line=file.readLine()) != null) {
+      if (line.equals(primaryStartTag)) {
+	line = file.readLine(); // goto the next line
+	st = new StringTokenizer(line, ",");
+        totalMutations = Double.parseDouble(st.nextToken());
+	totalAllocs = Double.parseDouble(st.nextToken(",")); // time
+        temp=file.readLine();
+	while (!temp.equals(startTag)) {
+	  temp=file.readLine();
+	}
+	
+	// Read Source Distances
+	temp = file.readLine(); // go to next line
+	do {
+	  st = new StringTokenizer(temp, ",");
+	  int index = Integer.parseInt(st.nextToken());
+          double value = Double.parseDouble(st.nextToken(","));
+          if (index == 0) 
+            zeroDistance = value;
+          else if (index < 0)
+            negative[-index-1] = value;
+          else 
+            positive[index-1] = value;
+
+	  temp=file.readLine();
+	} while(!temp.equals(endTag));
+
+        sum = zeroDistance;
+	for(int i=0; i<read_pos_buckets; i++) {
+	  sum += positive[i];
+	}
+	for(int i=0; i<read_neg_buckets; i++) {
+	  sum += negative[i];
+	}
+	
+	double cp = ((zeroDistance/sum)*100)/2;
+	// add positive dists to XYSeries
+	for(int i=0; i<positive.length; i++) {
+	  if (posdistances[i] == null) {
+	    posdistances[i]= new XYSeries("+ve Bucket " + i);
+	  }
+          cp += (positive[i]/sum)*100;
+	  if (!isTimeAllocs) {
+	    posdistances[i].add(totalMutations/1000000, cp);
+	  } else {
+	    posdistances[i].add(totalAllocs, cp);
+	  }
+	}
+	
+	
+	// add negative dists to XYSeries
+	cp = -((zeroDistance/sum)*100)/2;
+	for(int i=0; i<negative.length; i++) {
+	  if (negdistances[i] == null) {
+	    negdistances[i]= new XYSeries("-ve Bucket " + i);
+	  }
+          cp -= (negative[i]/sum)*100;
+	  if (!isTimeAllocs) {
+	    negdistances[i].add(totalMutations/1000000, cp);
+	  } else {
+	    negdistances[i].add(totalAllocs, cp);
+	  }
+	}
+	
+	// reset arrays
+	for(int i=0; i<read_pos_buckets; i++) positive[i] = 0;
+	for(int i=0; i<read_neg_buckets; i++) negative[i] = 0;
+	zeroDistance = 0;
+
+	totalPositive = 0;
+	totalNegative = 0;
+	sum = 0;
+	
+	// reset in case values changed
+	read_pos_buckets = READ_POS_BUCKETS;
+	read_neg_buckets = READ_NEG_BUCKETS;
+      }
+    }
+    
+    // add XYSeries to the collection
+    for(int i=0;i<read_pos_buckets;i++) {
+      dataset.addSeries(posdistances[i]);
+    }
+    
+    // add XYSeries to the collection
+    for(int i=0;i<read_neg_buckets;i++) {
+      dataset.addSeries(negdistances[i]);
+    }
+
+    positiveSeriesCount = maxPosFound;
+    negativeSeriesCount = maxNegFound;
+
+    return dataset;
+  }
+  
+  private static XYSeriesCollection createPointerAgeData(URL inURL,
+							 boolean isSource,
+							 boolean isPerfect,
+                                                         boolean isMutation,
+							 int timeline) 
+    throws IOException {
+    BufferedReader file = new BufferedReader(new InputStreamReader(inURL.openStream()));
+
+    String line = null;
+    String temp = null;
+    StringTokenizer st;
+    
+    int maxAges = 32;
+    
+    double[] ages = null; 
+    int totalAges = 0; 
+    double sum = 0;
+    
+    XYSeriesCollection dataset = new XYSeriesCollection();
+    XYSeries[] ptrages = new XYSeries[maxAges];
+    int maxFound = 0;
+    
+    double[] mutationHistory = new double[maxAges];
+    
+    double totalMutations = 0;
+    double totalAllocs = 0;
+    double currentMutations = 0;
+    boolean isTimeAllocs = false;
+    
+    String mutOrPoint = ((isMutation) ? "mutation " : "pointer ");
+    String primaryStartTag = "<"+mutOrPoint+"data>";
+    String primaryEndTag = "</"+mutOrPoint+"data>";
+    String baseTag = ((isPerfect) ? "perfect " : "") + mutOrPoint
+      + ((isSource) ? "src" : "tgt");
+    String startTag = "<"+baseTag+">";
+    String endTag = "</"+baseTag+">";
+    
+    switch (timeline) {
+    case TIMELINE_MUTATIONS:
+      isTimeAllocs = false; break;
+    case TIMELINE_ALLOCATIONS:
+      isTimeAllocs = true; break;
+    default: break;
+    }
+    
+    ages = new double[maxAges]; // 0 -> 2^30
+    
+    
+    //NO NEED FOR THIS
+    // we'll initialize them later.. just to make sure they're all null
+    for(int i=0; i<maxAges; i++) {
+      ptrages[i] = null;
+    }
+    
+    // How many buckets to read
+    final int READ_AGE_BUCKETS = maxAges;
+    
+    // Do not change this, instead change READ_AGE_BUCKETS
+    int read_age_buckets = READ_AGE_BUCKETS;
+    
+    while((line=file.readLine()) != null) {
+      if (line.equals(primaryStartTag)) {
+	line = file.readLine(); // goto the next line
+	st = new StringTokenizer(line, ",");
+        totalMutations = Double.parseDouble(st.nextToken());
+	totalAllocs = Double.parseDouble(st.nextToken(",")); // time
+        temp=file.readLine();
+	while (!temp.equals(startTag)) {
+	  temp=file.readLine();
+	}
+	
+	// Read Source Distances
+	temp = file.readLine(); // go to next line
+	do {
+	  ++totalAges;
+	  st = new StringTokenizer(temp, ",");
+	  int index = Integer.parseInt(st.nextToken());
+	  ages[index]= Double.parseDouble(st.nextToken(","));
+	  temp=file.readLine();
+	  maxFound=(totalAges>maxFound)?totalAges:maxFound;
+	  if (totalAges == read_age_buckets) {
+	    break;
+	  }
+
+	} while(!temp.equals(endTag));
+	
+	// read_age_buckets can be less than READ_AGE_BUCKETS
+	// when totalAges is less, but it cannot be more than totalAges
+	read_age_buckets = maxFound;
+	
+	for(int i=0; i<read_age_buckets; i++) {
+	  sum += ages[i];
+	  mutationHistory[i] += ages[i];
+	}
+	
+	double cp = 0;
+	// add positive dists to XYSeries
+	for(int i=0; i<read_age_buckets; i++) {
+	  if (ptrages[i] == null) {
+	    ptrages[i]= new XYSeries("Bucket " + (i+1));
+	  }
+	  cp += (ages[i]/sum)*100;
+	  if (!isTimeAllocs) {
+	    ptrages[i].add(totalMutations/1000000, cp);
+	  } else {
+	    ptrages[i].add(totalAllocs, cp);
+	  }
+	}
+	
+	for(int i=0; i<read_age_buckets; i++) ages[i] = 0;
+	totalAges = 0;
+	sum = 0;
+	// in case read_age_buckets is less than READ_AGE_BUCKETS
+	read_age_buckets = READ_AGE_BUCKETS;
+      }
+    }
+    
+    double[] ageHist = new double[maxFound];
+    // add XYSeries to the collection
+    for(int i=0;i<read_age_buckets;i++) {
+      String series = new String("Bucket " +(i+1));
+      if(ptrages[i] == null) {
+	continue;
+      }
+      ageHist[i] = (mutationHistory[i]/totalMutations)*100;
+      dataset.addSeries(ptrages[i]);
+    }
+    
+    return dataset;
+  }
+  
+  
+  
+  private static double[][] createPtrAgeHistData(URL inURL,
+						 boolean isSource,
+						 boolean isPerfect,
+                                                 boolean isMutation,
+						 int timeline) 
+    throws IOException {
+    BufferedReader file = new BufferedReader(new InputStreamReader(inURL.openStream()));
+
+    String line = null;
+    String temp = null;
+    StringTokenizer st;
+    
+    int maxAges = 32;
+    
+    double[] ages = null; int totalAges = 0; double sum = 0;
+    
+    XYSeriesCollection dataset = new XYSeriesCollection();
+    XYSeries[] ptrages = new XYSeries[maxAges];
+    int maxFound = 0;
+    
+    double[] mutationHistory = new double[maxAges];
+    
+    double totalMutations = 0;
+    double totalAllocs = 0;
+    double currentMutations = 0;
+    boolean isTimeAllocs = false;
+    
+    String mutOrPoint = ((isMutation) ? "mutation " : "pointer ");
+    String primaryStartTag = "<"+mutOrPoint+"data>";
+    String primaryEndTag = "</"+mutOrPoint+"data>";
+    String baseTag = ((isPerfect) ? "perfect " : "") + mutOrPoint
+      + ((isSource) ? "src" : "tgt");
+    String startTag = "<"+baseTag+">";
+    String endTag = "</"+baseTag+">";
+    
+    switch (timeline) {
+    case TIMELINE_MUTATIONS:
+      isTimeAllocs = false; break;
+    case TIMELINE_ALLOCATIONS:
+      isTimeAllocs = true; break;
+    default: break;
+    }
+    
+    ages = new double[maxAges]; // 0 -> 2^30
+    
+    
+    //NO NEED FOR THIS
+    // we'll initialize them later.. just to make sure they're all null
+    for(int i=0; i<maxAges; i++) {
+      ptrages[i] = null;
+    }
+    
+    // How many buckets to read
+    final int READ_AGE_BUCKETS = maxAges;
+    
+    // Do not change this, instead change READ_AGE_BUCKETS
+    int read_age_buckets = READ_AGE_BUCKETS;
+    
+    while((line=file.readLine()) != null) {
+      if (line.equals(primaryStartTag)) {
+	line = file.readLine(); // goto the next line
+	st = new StringTokenizer(line, ",");
+        totalMutations = Double.parseDouble(st.nextToken());
+	totalAllocs = Double.parseDouble(st.nextToken(",")); // time
+        temp=file.readLine();
+	while (!temp.equals(startTag)) {
+	  temp=file.readLine();
+	}
+	
+	// Read Source Distances
+	temp = file.readLine(); // go to next line
+	do {
+	  ++totalAges;
+	  st = new StringTokenizer(temp, ",");
+	  int index = Integer.parseInt(st.nextToken());
+	  ages[index]= Double.parseDouble(st.nextToken(","));
+	  temp=file.readLine();
+	  maxFound=(totalAges>maxFound)?totalAges:maxFound;
+	  if (totalAges == read_age_buckets) {
+	    break;
+	  }
+
+	} while(!temp.equals(endTag));
+	
+	// read_age_buckets can be less than READ_AGE_BUCKETS
+	// when totalAges is less, but it cannot be more than totalAges
+	read_age_buckets = maxFound;
+	
+	for(int i=0; i<read_age_buckets; i++) {
+	  sum += ages[i];
+	  mutationHistory[i] += ages[i];
+	}
+	
+	double cp = 0;
+	// add positive dists to XYSeries
+	for(int i=0; i<read_age_buckets; i++) {
+	  if (ptrages[i] == null) {
+	    ptrages[i]= new XYSeries("Bucket " + (i+1));
+	  }
+	  cp += (ages[i]/sum)*100;
+	  if (!isTimeAllocs) {
+	    ptrages[i].add(totalMutations/1000000, cp);
+	  } else {
+	    ptrages[i].add(totalAllocs, cp);
+	  }
+	}
+	
+	for(int i=0; i<read_age_buckets; i++) ages[i] = 0;
+	totalAges = 0;
+	sum = 0;
+	// in case read_age_buckets is less than READ_AGE_BUCKETS
+	read_age_buckets = READ_AGE_BUCKETS;
+      }
+    }
+    
+    double[] ageHist = new double[maxFound];
+    // add XYSeries to the collection
+    for(int i=0;i<read_age_buckets;i++) {
+      String series = new String("Bucket " +(i+1));
+      if(ptrages[i] == null) {
+	continue;
+      }
+      ageHist[i] = (mutationHistory[i]/totalMutations)*100;
+      dataset.addSeries(ptrages[i]);
+    }
+    return new double[][]{ageHist};
+  }
+
+  public static int getPosSeriesCount() {
+    int pos = positiveSeriesCount;
+    positiveSeriesCount = 0;
+    return pos;
+  }
+
+  public static int getNegSeriesCount() {
+    int neg = negativeSeriesCount;
+    negativeSeriesCount = 0;
+    return neg;
+  }
+
+  private static int getMaxCohorts(URL inURL)
+    throws IOException {
+    int maxCohort = 20000; // FIXME!!!
+    String line = null;
+    BufferedReader file = new BufferedReader(new InputStreamReader(inURL.openStream()));
+      
+      while((line=file.readLine()) != null) {
+	if (line.equals("[max cohorts]")) {
+	  maxCohort = Integer.parseInt(file.readLine());
+	}
+      }
+      return maxCohort;
+  }
+}
diff -N -u -r chart/dacapo/Graph.java chart/dacapo/Graph.java
--- chart/dacapo/Graph.java	1970-01-01 10:00:00.000000000 +1000
+++ chart/dacapo/Graph.java	2005-09-27 11:43:51.000000000 +1000
@@ -0,0 +1,645 @@
+package dacapo;
+
+import org.jfree.chart.*;
+import org.jfree.chart.axis.*;
+import org.jfree.chart.plot.*;
+import org.jfree.chart.renderer.*;
+import org.jfree.chart.renderer.category.*;
+import org.jfree.chart.renderer.xy.*;
+import org.jfree.chart.title.*;
+import org.jfree.data.*;
+import org.jfree.data.category.*;
+import org.jfree.data.general.*;
+import org.jfree.data.xy.*;
+import org.jfree.ui.*;
+
+import com.lowagie.text.*;
+import com.lowagie.text.pdf.*;
+
+import java.awt.*;
+import java.awt.geom.*;
+import java.io.*;
+import java.net.URL;
+
+public class Graph implements GraphConstants {
+  
+  public Graph(URL fromURL, int chartType) {
+    plotGraph(fromURL, DEFAULT_TO_FILE, "", chartType, TIMELINE_MUTATIONS,
+              RANGE_IN_MB, DEFAULT_WIDTH, DEFAULT_HEIGHT, false);
+  }
+
+  public Graph(URL fromURL, int chartType, String extraTitle) {
+    plotGraph(fromURL, DEFAULT_TO_FILE, extraTitle, chartType, 
+	      TIMELINE_MUTATIONS, RANGE_IN_MB, DEFAULT_WIDTH, DEFAULT_HEIGHT,
+	      false);
+  }
+
+  public Graph(URL fromURL,int chartType, String extraTitle,int timeLine) {
+    plotGraph(fromURL, DEFAULT_TO_FILE, extraTitle, chartType, timeLine,
+              RANGE_IN_MB, DEFAULT_WIDTH, DEFAULT_HEIGHT, false);
+  }
+  
+  public Graph(URL fromURL, String toFile, int chartType){
+    plotGraph(fromURL, toFile, "", chartType, TIMELINE_MUTATIONS,
+              RANGE_IN_MB, DEFAULT_WIDTH, DEFAULT_HEIGHT, false);
+  }
+  
+  public Graph(URL fromURL, int chartType, boolean isSmallGraph) {
+    plotGraph(fromURL, DEFAULT_TO_FILE, "", chartType, TIMELINE_MUTATIONS,
+              RANGE_IN_MB, DEFAULT_WIDTH, DEFAULT_HEIGHT, isSmallGraph);
+  }
+  
+  public Graph(URL fromURL, int chartType, boolean isSmallGraph, 
+	       String extraTitle) {
+    plotGraph(fromURL, DEFAULT_TO_FILE, extraTitle, chartType, 
+	      TIMELINE_MUTATIONS, RANGE_IN_MB, DEFAULT_WIDTH, DEFAULT_HEIGHT, 
+	      isSmallGraph);
+  }
+
+  public Graph(URL fromURL, int chartType, boolean isSmallGraph, 
+	       String extraTitle, int timeLine) {
+    plotGraph(fromURL, DEFAULT_TO_FILE, extraTitle, chartType, timeLine,
+              RANGE_IN_MB, DEFAULT_WIDTH, DEFAULT_HEIGHT, isSmallGraph);
+  }
+  
+  public Graph(URL fromURL, String toFile, int chartType, 
+	       boolean isSmallGraph) {
+    plotGraph(fromURL, toFile, "", chartType, TIMELINE_MUTATIONS,
+              RANGE_IN_MB, DEFAULT_WIDTH, DEFAULT_HEIGHT, isSmallGraph);
+  }
+  
+  public Graph(URL fromURL, int chartType, int timeLine) {
+    plotGraph(fromURL, DEFAULT_TO_FILE, "", chartType, timeLine, 
+              RANGE_IN_MB, DEFAULT_WIDTH, DEFAULT_HEIGHT, false);
+  }
+  
+  public Graph(URL fromURL, String toFile, int chartType, int timeLine) {
+    plotGraph(fromURL, toFile, "", chartType, timeLine, RANGE_IN_MB, 
+              DEFAULT_WIDTH, DEFAULT_HEIGHT, false);
+  }
+  
+  public Graph(URL fromURL, int chartType, int timeLine, 
+	       boolean isSmallGraph) {
+    plotGraph(fromURL, DEFAULT_TO_FILE, "", chartType, timeLine, 
+              RANGE_IN_MB, DEFAULT_WIDTH, DEFAULT_HEIGHT, isSmallGraph);
+  }
+  
+  public Graph(URL fromURL, String toFile, int chartType, int timeLine, 
+	       boolean isSmallGraph) {
+    plotGraph(fromURL, toFile, "", chartType, timeLine, RANGE_IN_MB, 
+              DEFAULT_WIDTH, DEFAULT_HEIGHT, isSmallGraph);
+  }
+  
+  public Graph(URL fromURL, int chartType, int timeLine, int width, 
+	       int height) {
+    plotGraph(fromURL, DEFAULT_TO_FILE, "", chartType, timeLine, 
+              RANGE_IN_MB, width, height, false);
+  }
+  
+  private void plotGraph(URL fromURL, String toFile, String extraTitle, 
+			 int chartType, int timeLine, 
+			 int rangeType, int width, int height, 
+			 boolean isSmallGraph) {
+    
+    CategoryDataset histData = null;
+    XYSeriesCollection chartData = null;
+    
+    String chartTitle = null;
+    String domainAxisLabel = null;
+    String rangeAxisLabel = null;
+    
+    int graph_width = width;
+    int graph_height = height;
+
+    JFreeChart chart = null;
+    
+    OutputStream fileOut = null;
+    Document pdfDoc;
+    PdfContentByte cb = null;
+    PdfTemplate tp = null;
+    DefaultFontMapper mapper = new DefaultFontMapper();
+    Graphics2D g2 = null;
+    Rectangle2D r2D;
+
+    PdfWriter writer = null;
+    String fileName = toFile;
+    
+    int graphType = getGraphType(chartType);
+
+    if (fileName.equals(DEFAULT_TO_FILE)) {
+      fileName = getFilenameToSave(chartType);
+    }
+    
+    if (extraTitle.equals("")) {
+      chartTitle = new String(getChartTitleFromType(chartType));
+    } else {
+      chartTitle = new String(extraTitle);
+    }
+    
+    try {
+      if (isSmallGraph) fileName = fileName + "-sm";
+      fileName = fileName + ".pdf";
+
+      switch (graphType) {
+      case HISTOGRAM_TYPE:
+	if (isSmallGraph) {
+	  graph_width = SMALL_HISTOGRAM_WIDTH; 
+	  graph_height = SMALL_HISTOGRAM_HEIGHT;
+	}
+	fileOut = new BufferedOutputStream(new FileOutputStream(fileName));
+	
+	pdfDoc = new Document(new com.lowagie.text.Rectangle(graph_width, 
+							     graph_height));
+	writer = PdfWriter.getInstance(pdfDoc, fileOut);
+
+	histData = Datasets.getHistDataset(fromURL, chartType, timeLine, 
+					   rangeType); 
+
+	domainAxisLabel = getHistogramDomainLabel(chartType);
+	rangeAxisLabel = getRangeLabel(chartType);
+	
+	chart = ChartFactory.createStackedBarChart(chartTitle, domainAxisLabel,
+						   rangeAxisLabel, histData,
+						   PlotOrientation.VERTICAL,
+						   false, true, false);
+	
+	CategoryPlot catPlot = chart.getCategoryPlot();
+	makeReadable(catPlot, !isSmallGraph, chartType);
+        //	makeReadable(catPlot, true, chartType);
+	
+	if (isSmallGraph) {
+	  chart.getTitle().setFont(new java.awt.Font("SansSerif", 
+						     java.awt.Font.PLAIN, 10));
+	}
+	
+	chart.setBorderVisible(false);
+	chart.setBackgroundPaint(Color.white);
+
+	pdfDoc.open();
+
+        cb = writer.getDirectContent();
+        tp = cb.createTemplate(graph_width, graph_height);
+        g2 = tp.createGraphics(graph_width,graph_height,mapper);
+
+	r2D = new Rectangle2D.Double(0, 0, graph_width, graph_height);
+        chart.draw(g2,r2D,null);
+        g2.dispose();
+        cb.addTemplate(tp,0,0);
+	
+	pdfDoc.close();
+	break;
+      case LINEGRAPH_TYPE:
+	if (isSmallGraph) {
+	  graph_width = SMALL_WIDTH; 
+	  graph_height = SMALL_HEIGHT;
+
+	  if (chartType == PERFECT_HEAP_COMP_XYPLOT) {
+	    graph_height += 10;
+	  }
+	}
+	fileOut = new BufferedOutputStream(new FileOutputStream(fileName));
+
+	pdfDoc = new Document(new com.lowagie.text.Rectangle(graph_width, 
+							     graph_height));
+	writer = PdfWriter.getInstance(pdfDoc, fileOut);
+	
+	if (chartType == PERFECT_INV_HEAP_COMP_XYPLOT) {
+	  rangeType = RANGE_IN_KB;
+	}
+
+	chartData = Datasets.getLineDataset(fromURL, chartType, 
+					    timeLine, rangeType); 
+	
+	domainAxisLabel = getLineGraphDomainLabel(timeLine);
+	rangeAxisLabel = getRangeLabel(chartType);
+	
+	chart = ChartFactory.createXYLineChart(chartTitle, domainAxisLabel,
+					       rangeAxisLabel, chartData,
+					       PlotOrientation.VERTICAL,
+					       false, true, false);
+	
+	XYPlot xyPlot = chart.getXYPlot();
+	makeReadable(xyPlot, !isSmallGraph, chartType);
+
+	if (isSmallGraph) {
+	  chart.getTitle().setFont(new java.awt.Font("SansSerif", 
+						     java.awt.Font.PLAIN, 10));
+	}
+
+	chart.setBorderVisible(false);
+	chart.setBackgroundPaint(Color.white);
+	chart.getTitle().setHorizontalAlignment(HorizontalAlignment.CENTER);
+	chart.getTitle().setPosition(RectangleEdge.BOTTOM);
+
+	pdfDoc.open();
+
+	cb = writer.getDirectContent();
+	tp = cb.createTemplate(graph_width, graph_height);
+	g2 = tp.createGraphics(graph_width, graph_height, mapper);
+	
+	r2D = new Rectangle2D.Double(0, 0, graph_width, graph_height);
+	chart.draw(g2, r2D, null);
+	g2.dispose();
+	cb.addTemplate(tp, 0, 0);
+
+	pdfDoc.close();
+	break;
+      default: System.out.println("plotGraph: No such graph type"); break;
+      }
+      
+      System.out.println("Done plotting: " + fileName);
+    }
+    catch(Exception ex) { System.out.println("Exception " + ex);}
+  }
+  
+  public String getChartTitleFromType(int chartType) {
+    String title = "Graph";
+    
+    switch (chartType) {
+      // Histograms
+    case PERFECT_PTR_DIST_HIST:
+      title = "Pointer Distance (\"perfect\" heap)"; break;
+    case PERFECT_PTR_SRC_HIST:
+      title = "Pointer Source (\"perfect\" heap)"; break;
+    case PERFECT_PTR_TGT_HIST:
+      title = "Pointer Target (\"perfect\" heap)"; break;
+    case PERFECT_MUT_DIST_HIST:
+      title = "Mutation Distance (\"perfect\" heap)"; break;
+    case PERFECT_MUT_SRC_HIST:
+      title = "Mutation Source (\"perfect\" heap)"; break;
+    case PERFECT_MUT_TGT_HIST:
+      title = "Mutation Target (\"perfect\" heap)"; break;
+    case PERFECT_HEAP_COMP_HIST:
+      title = "Heap Composition"; break;
+    case PERFECT_INV_HEAP_COMP_HIST:
+      title = "Inverted Heap Composition"; break;
+    case CUMULATIVE_PTR_DIST_HIST:
+      title = "Pointer Distance"; break;
+    case CUMULATIVE_PTR_SRC_HIST:
+      title = "Pointer Source"; break;
+    case CUMULATIVE_PTR_TGT_HIST:
+      title = "Pointer Target"; break;
+    case CUMULATIVE_MUT_DIST_HIST:
+      title = "Mutation Distance"; break;
+    case CUMULATIVE_MUT_SRC_HIST:
+      title = "Mutation Source"; break;
+    case CUMULATIVE_MUT_TGT_HIST:
+      title = "Mutation Target"; break;
+      
+      // XY-Line graphs
+    case PERFECT_PTR_DIST_XYPLOT:
+      title = "Pointer Distance Time-series (\"perfect\" heap)"; break;
+    case PERFECT_PTR_SRC_XYPLOT:
+      title = "Pointer Source Time-series (\"perfect\" heap)"; break;
+    case PERFECT_PTR_TGT_XYPLOT:
+      title = "Pointer Target Time-series (\"perfect\" heap)"; break;
+    case PERFECT_MUT_DIST_XYPLOT:
+      title = "Mutation Distance Time-series (\"perfect\" heap)"; break;
+    case PERFECT_MUT_SRC_XYPLOT:
+      title = "Mutation Source Time-series (\"perfect\" heap)"; break;
+    case PERFECT_MUT_TGT_XYPLOT:
+      title = "Mutation Target Time-series (\"perfect\" heap)"; break;
+    case PERFECT_HEAP_COMP_XYPLOT:
+      title = "Heap Composition Time-series"; break;
+    case PERFECT_INV_HEAP_COMP_XYPLOT:
+      title = "Inverted Heap Composition Time-series"; break;
+    case CUMULATIVE_PTR_DIST_XYPLOT:
+      title = "Pointer Distance Time-series"; break;
+    case CUMULATIVE_PTR_SRC_XYPLOT:
+      title = "Pointer Source Time-series"; break;
+    case CUMULATIVE_PTR_TGT_XYPLOT:
+      title = "Pointer Target Time-series"; break;
+    case CUMULATIVE_MUT_DIST_XYPLOT:
+      title = "Mutation Distance Time-series"; break;
+    case CUMULATIVE_MUT_SRC_XYPLOT:
+      title = "Mutation Source Time-series"; break;
+    case CUMULATIVE_MUT_TGT_XYPLOT:
+      title = "Mutation Target Time-series"; break;
+    default: 
+      System.out.println("getChartTitleFromType: No such graph"); break;
+    }     
+    return title;
+  }
+  
+  
+  public String getHistogramDomainLabel(int chartType) {
+    String label = "X";
+    
+    switch (chartType) {
+      // Histograms
+    case PERFECT_PTR_DIST_HIST:
+    case PERFECT_PTR_SRC_HIST:
+    case PERFECT_PTR_TGT_HIST:
+    case CUMULATIVE_PTR_DIST_HIST:
+    case CUMULATIVE_PTR_SRC_HIST:
+    case CUMULATIVE_PTR_TGT_HIST:
+      label = "Log_2 of Pointer Distances (Bytes)"; break;
+    case PERFECT_MUT_DIST_HIST:
+    case PERFECT_MUT_SRC_HIST:
+    case PERFECT_MUT_TGT_HIST:
+    case CUMULATIVE_MUT_DIST_HIST:
+    case CUMULATIVE_MUT_SRC_HIST:
+    case CUMULATIVE_MUT_TGT_HIST:
+      label = "Log_2 of Mutation Distances (Bytes)"; break;
+    case PERFECT_HEAP_COMP_HIST:
+    case PERFECT_INV_HEAP_COMP_HIST:
+      label = "Cohorts"; break;
+    default: 
+      System.out.println("getHistogramDomainLabel: No such graph"); break;
+    }     
+    return label;
+  }
+  
+  public String getLineGraphDomainLabel(int timeLine) {
+    String label = "X";
+    
+    switch(timeLine) {
+    case TIMELINE_MUTATIONS:
+      label = "Mutations (in millions)"; break;
+    case TIMELINE_ALLOCATIONS:
+      label = "Allocations (KB)"; break;
+    default: 
+      System.out.println("getLineGraphDomainLabel: No such timeline");
+      break;
+    }
+    return label;
+  }
+  
+  public String getRangeLabel(int chartType) {
+    String label = "X";
+    
+    switch(chartType) {
+      // Histograms
+    case PERFECT_PTR_DIST_HIST:
+    case PERFECT_PTR_SRC_HIST:
+    case PERFECT_PTR_TGT_HIST:
+    case CUMULATIVE_PTR_DIST_HIST:
+    case CUMULATIVE_PTR_SRC_HIST:
+    case CUMULATIVE_PTR_TGT_HIST:
+    case PERFECT_MUT_DIST_HIST:
+    case PERFECT_MUT_SRC_HIST:
+    case PERFECT_MUT_TGT_HIST:
+    case CUMULATIVE_MUT_DIST_HIST:
+    case CUMULATIVE_MUT_SRC_HIST:
+    case CUMULATIVE_MUT_TGT_HIST:
+      label = "Pointer Mutations (%)"; break;
+    case PERFECT_HEAP_COMP_HIST:
+    case PERFECT_INV_HEAP_COMP_HIST:
+      label = "Volume (MB)"; break;
+      
+      // XY-Line graphs
+    case PERFECT_PTR_DIST_XYPLOT:
+    case PERFECT_PTR_SRC_XYPLOT:
+    case PERFECT_PTR_TGT_XYPLOT:
+    case CUMULATIVE_PTR_DIST_XYPLOT:
+    case CUMULATIVE_PTR_SRC_XYPLOT:
+    case CUMULATIVE_PTR_TGT_XYPLOT:
+    case PERFECT_MUT_DIST_XYPLOT:
+    case PERFECT_MUT_SRC_XYPLOT:
+    case PERFECT_MUT_TGT_XYPLOT:
+    case CUMULATIVE_MUT_DIST_XYPLOT:
+    case CUMULATIVE_MUT_SRC_XYPLOT:
+    case CUMULATIVE_MUT_TGT_XYPLOT:
+      label = "Distances (%)"; break;
+    case PERFECT_HEAP_COMP_XYPLOT:
+      label = "Cohort Volume (MB)"; break;
+    case PERFECT_INV_HEAP_COMP_XYPLOT:
+      label = "Cohort Volume (KB)"; break;
+    default: System.out.println("getRangeLabel: No such range type"); break;
+    }
+    return label;
+  }
+  public String getFilenameToSave(int chartType) {
+    String filename = "graph";
+    
+    switch (chartType) {
+      // Histograms
+    case PERFECT_PTR_DIST_HIST:
+      filename = "dst-ptr-prf-hist"; break;
+    case PERFECT_PTR_SRC_HIST:
+      filename = "src-ptr-prf-hist"; break;
+    case PERFECT_PTR_TGT_HIST:
+      filename = "tgt-ptr-prf-hist"; break;
+
+    case PERFECT_MUT_DIST_HIST:
+      filename = "dst-mut-prf-hist"; break;
+    case PERFECT_MUT_SRC_HIST:
+      filename = "src-mut-prf-hist"; break;
+    case PERFECT_MUT_TGT_HIST:
+      filename = "tgt-mut-prf-hist"; break;
+
+    case CUMULATIVE_PTR_DIST_HIST:
+      filename = "dst-ptr-inf-hist"; break;
+    case CUMULATIVE_PTR_SRC_HIST:
+      filename = "src-ptr-inf-hist"; break;
+    case CUMULATIVE_PTR_TGT_HIST:
+      filename = "tgt-ptr-inf-hist"; break;
+
+    case CUMULATIVE_MUT_DIST_HIST:
+      filename = "dst-mut-inf-hist"; break;
+    case CUMULATIVE_MUT_SRC_HIST:
+      filename = "src-mut-inf-hist"; break;
+    case CUMULATIVE_MUT_TGT_HIST:
+      filename = "tgt-mut-inf-hist"; break;
+
+      // XY-Line graphs
+    case PERFECT_PTR_DIST_XYPLOT:
+      filename = "dst-ptr-prf-time"; break;
+    case PERFECT_PTR_SRC_XYPLOT:
+      filename = "src-ptr-prf-time"; break;
+    case PERFECT_PTR_TGT_XYPLOT:
+      filename = "tgt-ptr-prf-time"; break;
+
+    case PERFECT_MUT_DIST_XYPLOT:
+      filename = "dst-mut-prf-time"; break;
+    case PERFECT_MUT_SRC_XYPLOT:
+      filename = "src-mut-prf-time"; break;
+    case PERFECT_MUT_TGT_XYPLOT:
+      filename = "tgt-mut-prf-time"; break;
+
+    case CUMULATIVE_PTR_DIST_XYPLOT:
+      filename = "dst-ptr-inf-time"; break;
+    case CUMULATIVE_PTR_SRC_XYPLOT:
+      filename = "src-ptr-inf-time"; break;
+    case CUMULATIVE_PTR_TGT_XYPLOT:
+      filename = "tgt-ptr-inf-time"; break;
+
+    case CUMULATIVE_MUT_DIST_XYPLOT:
+      filename = "dst-mut-inf-time"; break;
+    case CUMULATIVE_MUT_SRC_XYPLOT:
+      filename = "src-mut-inf-time"; break;
+    case CUMULATIVE_MUT_TGT_XYPLOT:
+      filename = "tgt-mut-inf-time"; break;
+
+    case PERFECT_HEAP_COMP_XYPLOT:
+      filename = "heap-comp-b"; break;
+    case PERFECT_INV_HEAP_COMP_XYPLOT:
+      filename = "heap-comp-a"; break;
+    default: 
+	  System.out.println("getFilenameToSave: No such chart type"); break;
+    }     
+
+    return new String(Plotter.filePrefix + filename);
+  }
+  
+  private int getGraphType(int chartType) {
+    // Add new chart types under the correct graph type
+
+    switch (chartType) {
+      // Histograms
+    case PERFECT_PTR_DIST_HIST:
+    case PERFECT_PTR_SRC_HIST:
+    case PERFECT_PTR_TGT_HIST:
+    case PERFECT_MUT_DIST_HIST:
+    case PERFECT_MUT_SRC_HIST:
+    case PERFECT_MUT_TGT_HIST:
+    case PERFECT_HEAP_COMP_HIST:
+    case PERFECT_INV_HEAP_COMP_HIST:
+    case CUMULATIVE_PTR_DIST_HIST:
+    case CUMULATIVE_PTR_SRC_HIST:
+    case CUMULATIVE_PTR_TGT_HIST:
+    case CUMULATIVE_MUT_DIST_HIST:
+    case CUMULATIVE_MUT_SRC_HIST:
+    case CUMULATIVE_MUT_TGT_HIST:
+      return HISTOGRAM_TYPE;
+      
+      // XY-Line graphs
+    case PERFECT_PTR_DIST_XYPLOT:
+    case PERFECT_PTR_SRC_XYPLOT:
+    case PERFECT_PTR_TGT_XYPLOT:
+    case PERFECT_MUT_DIST_XYPLOT:
+    case PERFECT_MUT_SRC_XYPLOT:
+    case PERFECT_MUT_TGT_XYPLOT:
+    case PERFECT_HEAP_COMP_XYPLOT:
+    case PERFECT_INV_HEAP_COMP_XYPLOT:
+    case CUMULATIVE_PTR_DIST_XYPLOT:
+    case CUMULATIVE_PTR_SRC_XYPLOT:
+    case CUMULATIVE_PTR_TGT_XYPLOT:
+    case CUMULATIVE_MUT_DIST_XYPLOT:
+    case CUMULATIVE_MUT_SRC_XYPLOT:
+    case CUMULATIVE_MUT_TGT_XYPLOT:
+      return LINEGRAPH_TYPE;
+    default: 
+      System.out.println("getGraphType: No such chart type"); break;
+    }
+    return -1;
+  }
+  
+  private void makeReadable(CategoryPlot plot, boolean isAxisVisible, 
+			    int chartType) {
+    
+    Color lightColor = Color.lightGray;
+    Color darkColor = Color.black;
+    
+    BarChartRenderer renderer = new BarChartRenderer();
+    plot.setRenderer(renderer);
+    plot.getDomainAxis().setVisible(isAxisVisible);
+    plot.getRangeAxis().setVisible(isAxisVisible);
+
+    // Set Fonts
+    plot.getDomainAxis().setLabelFont(new java.awt.Font("SansSerif", 
+						      java.awt.Font.PLAIN,10));
+    plot.getRangeAxis().setLabelFont(new java.awt.Font("SansSerif", 
+						      java.awt.Font.PLAIN,10));
+
+ //   if (chartType == PERFECT_HEAP_COMP_HIST 
+ //	|| chartType == PERFECT_INV_HEAP_COMP_HIST) {
+ //      plot.getDomainAxis().setSkipCategoryLabelsToFit(true);
+ //    }
+  }
+  
+  private void makeReadable(XYPlot plot,boolean isDomainVisible,int chartType){
+    
+    int posSeriesCount = 0;
+    int negSeriesCount = 0;
+    
+    BasicStroke light = new BasicStroke(0.8f);
+    Color lightColor = Color.lightGray;
+    
+    BasicStroke dark = new BasicStroke(1f);
+    Color darkColor = Color.black;
+    XYItemRenderer renderer = plot.getRenderer();
+    
+    int counter = 0;
+    switch (chartType) {
+      // XY-Line graphs
+    case PERFECT_PTR_DIST_XYPLOT:
+    case CUMULATIVE_PTR_DIST_XYPLOT:
+    case PERFECT_MUT_DIST_XYPLOT:
+    case CUMULATIVE_MUT_DIST_XYPLOT:
+      posSeriesCount = Datasets.getPosSeriesCount();
+      negSeriesCount = Datasets.getNegSeriesCount();
+
+      for(int i=0; i<posSeriesCount; i++){
+	if(i%5==0) {
+	  renderer.setSeriesStroke(i, dark);
+	  renderer.setSeriesPaint(i, darkColor);
+	} else {
+	  renderer.setSeriesStroke(i, light);
+	  renderer.setSeriesPaint(i, lightColor);
+	}
+      }
+
+      for(int i=posSeriesCount; i<=plot.getSeriesCount(); i++){
+	if(counter++ == 5) {
+	  renderer.setSeriesStroke(i, dark);
+	  renderer.setSeriesPaint(i, darkColor);
+	  counter = 1;
+	} else {
+	  renderer.setSeriesStroke(i, light);
+	  renderer.setSeriesPaint(i, lightColor);
+	}
+      }
+      renderer.setSeriesStroke(posSeriesCount, dark);
+      renderer.setSeriesPaint(posSeriesCount, darkColor);
+      break;
+    case PERFECT_PTR_SRC_XYPLOT:
+    case PERFECT_PTR_TGT_XYPLOT:
+    case CUMULATIVE_PTR_SRC_XYPLOT:
+    case CUMULATIVE_PTR_TGT_XYPLOT:
+    case PERFECT_MUT_SRC_XYPLOT:
+    case PERFECT_MUT_TGT_XYPLOT:
+    case CUMULATIVE_MUT_SRC_XYPLOT:
+    case CUMULATIVE_MUT_TGT_XYPLOT:
+    case PERFECT_HEAP_COMP_XYPLOT:
+    case PERFECT_INV_HEAP_COMP_XYPLOT:
+      for(int i=0; i<plot.getSeriesCount(); i++){
+	if(i%5==0) {
+	  renderer.setSeriesStroke(i, dark);
+	  renderer.setSeriesPaint(i, darkColor);
+	} else {
+	  renderer.setSeriesStroke(i, light);
+	  renderer.setSeriesPaint(i, lightColor);
+	}
+      }
+      break;
+    }
+    plot.getDomainAxis().setVisible(isDomainVisible);
+
+    // Set Fonts
+    plot.getDomainAxis().setLabelFont(new java.awt.Font("SansSerif", 
+						      java.awt.Font.PLAIN,10));
+    plot.getRangeAxis().setLabelFont(new java.awt.Font("SansSerif", 
+						      java.awt.Font.PLAIN,10));
+    
+    if ((chartType == PERFECT_HEAP_COMP_XYPLOT) && !isDomainVisible) {
+      plot.setDomainAxisLocation(AxisLocation.TOP_OR_RIGHT);      
+      plot.getDomainAxis().setVisible(true);
+    }
+  }
+}
+
+class BarChartRenderer extends StackedBarRenderer {
+  
+  private Color darkColor = Color.black;
+  private Color lightColor = Color.lightGray;
+  
+  public Paint getItemPaint(int row, int column) {
+    if (column%5==0) {
+      setPaint(darkColor);
+    } else {
+      setPaint(lightColor);
+    }
+    return super.getItemPaint(row, column);
+  }
+}
diff -N -u -r chart/dacapo/GraphConstants.java chart/dacapo/GraphConstants.java
--- chart/dacapo/GraphConstants.java	1970-01-01 10:00:00.000000000 +1000
+++ chart/dacapo/GraphConstants.java	2005-09-27 11:43:51.000000000 +1000
@@ -0,0 +1,65 @@
+package dacapo;
+
+public interface GraphConstants {
+  
+  // Graph Types
+  static final int HISTOGRAM_TYPE                = 40;
+  static final int LINEGRAPH_TYPE                = 50;
+  
+  // Chart Types: (Histograms)
+  static final int PERFECT_PTR_DIST_HIST         = 1;
+  static final int PERFECT_PTR_SRC_HIST          = 2;
+  static final int PERFECT_PTR_TGT_HIST          = 3;
+  static final int PERFECT_MUT_DIST_HIST         = 4;
+  static final int PERFECT_MUT_SRC_HIST          = 5;
+  static final int PERFECT_MUT_TGT_HIST          = 6;
+  static final int PERFECT_HEAP_COMP_HIST        = 7;
+  static final int PERFECT_INV_HEAP_COMP_HIST    = 8;
+  
+  static final int CUMULATIVE_PTR_DIST_HIST      = 9;
+  static final int CUMULATIVE_PTR_SRC_HIST       = 10;
+  static final int CUMULATIVE_PTR_TGT_HIST       = 11;
+  static final int CUMULATIVE_MUT_DIST_HIST      = 12;
+  static final int CUMULATIVE_MUT_SRC_HIST       = 13;
+  static final int CUMULATIVE_MUT_TGT_HIST       = 14;
+  
+  // Chart Types: (Line-graphs)
+  static final int PERFECT_PTR_DIST_XYPLOT       = 15;
+  static final int PERFECT_PTR_SRC_XYPLOT        = 16;
+  static final int PERFECT_PTR_TGT_XYPLOT        = 17;
+  static final int PERFECT_MUT_DIST_XYPLOT       = 18;
+  static final int PERFECT_MUT_SRC_XYPLOT        = 19;
+  static final int PERFECT_MUT_TGT_XYPLOT        = 20;
+  static final int PERFECT_HEAP_COMP_XYPLOT      = 21;
+  static final int PERFECT_INV_HEAP_COMP_XYPLOT  = 22;
+  
+  static final int CUMULATIVE_PTR_DIST_XYPLOT    = 23;
+  static final int CUMULATIVE_PTR_SRC_XYPLOT     = 24;
+  static final int CUMULATIVE_PTR_TGT_XYPLOT     = 25;
+  static final int CUMULATIVE_MUT_DIST_XYPLOT    = 26;
+  static final int CUMULATIVE_MUT_SRC_XYPLOT     = 27;
+  static final int CUMULATIVE_MUT_TGT_XYPLOT     = 28;
+  
+  // Timelines (x-axis)
+  static final int TIMELINE_MUTATIONS            = 29;
+  static final int TIMELINE_ALLOCATIONS          = 30;
+  
+  // Range axis (y-axis)
+  static final int RANGE_IN_KB                   = 31;
+  static final int RANGE_IN_MB                   = 32;
+  
+  // Graph sizes
+  static final int DEFAULT_WIDTH                 = 640;
+  static final int DEFAULT_HEIGHT                = 480;
+  
+//   static final int SMALL_WIDTH                   = 250;
+//   static final int SMALL_HEIGHT                  = 200;
+  static final int SMALL_WIDTH                   = 450;
+  static final int SMALL_HEIGHT                  = 200;
+  
+  static final int SMALL_HISTOGRAM_WIDTH         = SMALL_HEIGHT;
+  static final int SMALL_HISTOGRAM_HEIGHT        = SMALL_HEIGHT;
+  
+  // Save file as
+  static final String DEFAULT_TO_FILE            = "graph.jpeg";
+}
diff -N -u -r chart/dacapo/Plotter.java chart/dacapo/Plotter.java
--- chart/dacapo/Plotter.java	1970-01-01 10:00:00.000000000 +1000
+++ chart/dacapo/Plotter.java	2005-09-27 11:43:51.000000000 +1000
@@ -0,0 +1,141 @@
+package dacapo;
+import java.net.URL;
+
+public class Plotter implements GraphConstants{
+  
+  static String filePrefix;
+
+  public static void main(String[] args) {
+    String title = "";
+    String outputDir = "";
+    String prefix = "";
+    String dataFile;
+    int timeline = TIMELINE_MUTATIONS;
+    boolean simple = false;
+    
+    for (int i = 0; i < (args.length - 1); i++) {
+      if (args[i].equals("-d")) {
+        // name of output directory
+        outputDir = args[++i];
+      } else if (args[i].equals("-p")) {
+        // prefix
+        prefix = args[++i];
+      } else if (args[i].equals("small")) {
+        simple = true;
+      } else if (args[i].equals("large")) {
+        simple = false;
+      }
+    }
+    
+    filePrefix = new String(outputDir + "/" + prefix + "-");
+    ClassLoader cl = Plotter.class.getClassLoader();
+    URL in = cl.getResource(args[args.length - 1]);
+    
+    // LARGE GRAPH
+    // Perfect Line Graphs
+    Graph graph1 = new Graph(in, PERFECT_PTR_TGT_XYPLOT, title, 
+			     timeline);
+    Graph graph2 = new Graph(in, PERFECT_PTR_SRC_XYPLOT, title, 
+			     timeline);
+    Graph graph3 = new Graph(in, PERFECT_PTR_DIST_XYPLOT, title, 
+			     timeline);
+    Graph graph4 = new Graph(in, PERFECT_MUT_TGT_XYPLOT, title, 
+			     timeline);
+    Graph graph5 = new Graph(in, PERFECT_MUT_SRC_XYPLOT, title, 
+			     timeline);
+    Graph graph6 = new Graph(in, PERFECT_MUT_DIST_XYPLOT, title, 
+			     timeline);
+    Graph graph7 = new Graph(in, PERFECT_HEAP_COMP_XYPLOT, title, 
+			     timeline);
+    Graph graph8 = new Graph(in, PERFECT_INV_HEAP_COMP_XYPLOT, title, 
+			     timeline);
+    // Cumulative Line Graphs (Imperfect)
+    Graph graph9 = new Graph(in, CUMULATIVE_PTR_TGT_XYPLOT, title, 
+			     timeline);
+    Graph graph10= new Graph(in, CUMULATIVE_PTR_SRC_XYPLOT, title, 
+			     timeline);
+    Graph graph11= new Graph(in, CUMULATIVE_PTR_DIST_XYPLOT, title, 
+			     timeline);
+    Graph graph12= new Graph(in, CUMULATIVE_MUT_TGT_XYPLOT, title, 
+			     timeline);
+    Graph graph13= new Graph(in, CUMULATIVE_MUT_SRC_XYPLOT, title, 
+			     timeline);
+    Graph graph14= new Graph(in, CUMULATIVE_MUT_DIST_XYPLOT, title, 
+			     timeline);
+    if (simple) return;
+
+    
+    // Perfect Histograms
+    Graph graph15 = new Graph(in, PERFECT_PTR_TGT_HIST, title);
+    Graph graph16 = new Graph(in, PERFECT_PTR_SRC_HIST, title);
+    Graph graph17 = new Graph(in, PERFECT_PTR_DIST_HIST, title);
+    Graph graph18 = new Graph(in, PERFECT_MUT_TGT_HIST, title);
+    Graph graph19 = new Graph(in, PERFECT_MUT_SRC_HIST, title);
+    Graph graph20 = new Graph(in, PERFECT_MUT_DIST_HIST, title);
+    //    Graph graph14 = new Graph(in, PERFECT_HEAP_COMP_HIST, title);
+    //    Graph graph15 = new Graph(in, PERFECT_INV_HEAP_COMP_HIST, title);
+    
+    // Cumulative Histograms (Imperfect)
+    Graph graph21 = new Graph(in, CUMULATIVE_PTR_TGT_HIST, title);
+    Graph graph22 = new Graph(in, CUMULATIVE_PTR_SRC_HIST, title);
+    Graph graph23 = new Graph(in, CUMULATIVE_PTR_DIST_HIST, title);
+    Graph graph24 = new Graph(in, CUMULATIVE_MUT_TGT_HIST, title);
+    Graph graph25 = new Graph(in, CUMULATIVE_MUT_SRC_HIST, title);
+    Graph graph26 = new Graph(in, CUMULATIVE_MUT_DIST_HIST, title);
+
+    // SMALL GRAPHS
+    // Perfect Line Graphs
+    Graph graph27 = new Graph(in, PERFECT_PTR_TGT_XYPLOT, true, title, 
+			      timeline);
+    Graph graph28 = new Graph(in, PERFECT_PTR_SRC_XYPLOT, true, title, 
+			     timeline);
+    Graph graph29 = new Graph(in, PERFECT_PTR_DIST_XYPLOT, true, title, 
+			     timeline);
+    Graph graph30 = new Graph(in, PERFECT_MUT_TGT_XYPLOT, true, title, 
+			      timeline);
+    Graph graph31 = new Graph(in, PERFECT_MUT_SRC_XYPLOT, true, title, 
+			     timeline);
+    Graph graph32 = new Graph(in, PERFECT_MUT_DIST_XYPLOT, true, title, 
+			     timeline);
+    Graph graph33 = new Graph(in, PERFECT_HEAP_COMP_XYPLOT, true, title, 
+			     timeline);
+    Graph graph34 = new Graph(in, PERFECT_INV_HEAP_COMP_XYPLOT, true, 
+			      title, timeline);
+    // Cumulative Line Graphs (Imperfect)
+    Graph graph35 = new Graph(in, CUMULATIVE_PTR_TGT_XYPLOT, true, title,
+			      timeline);
+    Graph graph36 = new Graph(in, CUMULATIVE_PTR_SRC_XYPLOT, true, title,
+			      timeline);
+    Graph graph37 = new Graph(in, CUMULATIVE_PTR_DIST_XYPLOT, true,title,
+			      timeline);
+    Graph graph38 = new Graph(in, CUMULATIVE_MUT_TGT_XYPLOT, true, title,
+			      timeline);
+    Graph graph39 = new Graph(in, CUMULATIVE_MUT_SRC_XYPLOT, true, title,
+			      timeline);
+    Graph graph40 = new Graph(in, CUMULATIVE_MUT_DIST_XYPLOT, true,title,
+			      timeline);
+    
+    // Perfect Histograms
+    Graph graph41 = new Graph(in, PERFECT_PTR_TGT_HIST, true, title);
+    Graph graph42 = new Graph(in, PERFECT_PTR_SRC_HIST, true, title);
+    Graph graph43 = new Graph(in, PERFECT_PTR_DIST_HIST, true, title);
+    Graph graph44 = new Graph(in, PERFECT_MUT_TGT_HIST, true, title);
+    Graph graph45 = new Graph(in, PERFECT_MUT_SRC_HIST, true, title);
+    Graph graph46 = new Graph(in, PERFECT_MUT_DIST_HIST, true, title);
+//     Graph graph34 = new Graph(in, PERFECT_HEAP_COMP_HIST, true, title);
+//     Graph graph35 = new Graph(in, PERFECT_INV_HEAP_COMP_HIST,true,title);
+    
+    // Cumulative Histograms (Imperfect)
+    Graph graph47 = new Graph(in, CUMULATIVE_PTR_TGT_HIST, true, title);
+    Graph graph48 = new Graph(in, CUMULATIVE_PTR_SRC_HIST, true, title);
+    Graph graph49 = new Graph(in, CUMULATIVE_PTR_DIST_HIST, true, title);
+    Graph graph50 = new Graph(in, CUMULATIVE_MUT_TGT_HIST, true, title);
+    Graph graph51 = new Graph(in, CUMULATIVE_MUT_SRC_HIST, true, title);
+    Graph graph52 = new Graph(in, CUMULATIVE_MUT_DIST_HIST, true, title);
+  }
+
+  private static void printUsage() {
+      System.out.println("Usage: Plotter data_file [graph_title]\n");
+      System.exit(1);
+  }
+}
